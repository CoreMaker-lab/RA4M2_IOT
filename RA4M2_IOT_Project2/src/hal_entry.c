#include "hal_data.h"
#include <stdio.h>
FSP_CPP_HEADER
void R_BSP_WarmStart(bsp_warm_start_event_t event);
FSP_CPP_FOOTER

fsp_err_t err = FSP_SUCCESS;
volatile bool uart_send_complete_flag = false;
void user_uart_callback (uart_callback_args_t * p_args)
{
    if(p_args->event == UART_EVENT_TX_COMPLETE)
    {
        uart_send_complete_flag = true;
    }
}




#ifdef __GNUC__                                 //串口重定向
    #define PUTCHAR_PROTOTYPE int __io_putchar(int ch)
#else

#endif


PUTCHAR_PROTOTYPE
{
        err = R_SCI_UART_Write(&g_uart9_ctrl, (uint8_t *)&ch, 1);
        if(FSP_SUCCESS != err) __BKPT();
        while(uart_send_complete_flag == false){}
        uart_send_complete_flag = false;
        return ch;
}

int _write(int fd,char *pBuffer,int size)
{
    for(int i=0;i<size;i++)
    {
        __io_putchar(*pBuffer++);
    }
    return size;
}




volatile bool uart_wifi_RX_flag = false;
volatile bool uart_wifi_TX_flag = false;
#define UART0_LENGTH  255
uint8_t  TUYA_wifi_buffer[UART0_LENGTH];
uint32_t UART0_TUYA_LENGTH = 0;
uint32_t UART0_TUYA_flag = 0;
void user_uart_callback0 (uart_callback_args_t * p_args)
{
    /* Receive complete */
    if(p_args->event == UART_EVENT_RX_COMPLETE)
    {
        uart_wifi_RX_flag = true;
    }
    /* Transmit complete */
    else if(p_args->event == UART_EVENT_TX_COMPLETE)
    {
        uart_wifi_TX_flag = true;
    }
    else if(p_args->event == UART_EVENT_RX_CHAR)
    {
        /* Only put the next character in the receive buffer if there is space for it */
        if (sizeof(TUYA_wifi_buffer) > UART0_TUYA_LENGTH)
        {
            /* Write either the next one or two bytes depending on the receive data size */
            if (UART_DATA_BITS_8 >= g_uart0_cfg.data_bits)
            {
                TUYA_wifi_buffer[UART0_TUYA_LENGTH++] = (uint8_t) p_args->data;
            }
            if(TUYA_wifi_buffer[00]!=0x55)
                UART0_TUYA_LENGTH--;
            if(UART0_TUYA_LENGTH>=6)
                UART0_TUYA_flag=1;

        }

        }

}

void uart0_tuya(void);
uint8_t wifi_first =0;//第一次开启 发送00  第二次发送01
uint32_t wifi_num =0;//如果心跳频繁发送，可能是触发了复位，需要重新发送buff1，这里2秒内多次发送心跳指令则认为重启
const uint8_t Buff1[8]={0x55,0xAA,0x03,0x00,0x00,0x01,0x00,0x03};//心跳检测,第1次 0x55 aa 00 00 00 01 00 03
const uint8_t Buff2[8]={0x55,0xAA,0x03,0x00,0x00,0x01,0x01,0x04};//心跳检测,第2次 0x55 aa 00 00 00 01 01 04

//55 AA 03 01 (帧头)
//00 2A       (长度)
//7B 22 70 22 3A 22 ({"p":")
//62 66 68 6F 7A 6F 65 7A 7A 73 74 75 6C 73 32 75 (bfhozoezzstuls2u)
//22 2C 22 76 22 3A 22 (","v":")
//31 2E 30 2E 30  (1.0.0)
//22 2C 22     6D 22 3A (","m":)
//30  (0)
//7D(})
//B2(校验码)
uint8_t Buff4[49]={0x55,0xAA,0x03,0x01,0x00,0x2A,0x7B,0x22,0x70,0x22,
                                     0x3A,0x22,0x62,0x66,0x68,0x6F,0x7A,0x6F,0x65,0x7A,
                                     0x7A,0x73,0x74,0x75,0x6C,0x73,0x32,0x75,0x22,0x2C,
                                     0x22,0x76,0x22,0x3A,0x22,0x31,0x2E,0x30,0x2E,0x30,
                                     0x22,0x2C,0x22,0x6D,0x22,0x3A,0x30,0x7D,0xB2
};//接收模块发送的查询产品信息请求

const uint8_t Buff5[8]={0x55,0xaa,0x03,0x02,0x00,0x00,0x04};//查询工作模式
/*******************************************************************************************************************//**
 * main() is generated by the RA Configuration editor and is used to generate threads if an RTOS is used.  This function
 * is called by main() when no RTOS is used.
 **********************************************************************************************************************/
void hal_entry(void)
{
    /* TODO: add your own code here */

    /* Open the transfer instance with initial configuration. */
    err = R_SCI_UART_Open(&g_uart9_ctrl, &g_uart9_cfg);
    assert(FSP_SUCCESS == err);

    unsigned char buff[]="RA E2STUDIO";
    uint8_t buff_len = strlen(buff);
    err = R_SCI_UART_Write(&g_uart9_ctrl, buff, buff_len);
    if(FSP_SUCCESS != err) __BKPT();
    while(uart_send_complete_flag == false){}
    uart_send_complete_flag = false;


    printf("\nhello world!\r\n");

    /* Open the transfer instance with initial configuration. */
    err = R_SCI_UART_Open(&g_uart0_ctrl, &g_uart0_cfg);
    assert(FSP_SUCCESS == err);


    while(1)
    {
        uart2_data();
        if(wifi_num<10000)
            wifi_num++;

        R_BSP_SoftwareDelay(1, BSP_DELAY_UNITS_MILLISECONDS); //
    }

#if BSP_TZ_SECURE_BUILD
    /* Enter non-secure code */
    R_BSP_NonSecureEnter();
#endif
}
void uart2_data(void)
{
    if( UART0_TUYA_flag==1)
    {

        if(TUYA_wifi_buffer[3]==0x00)//判断是否为心跳检测
        {
            if(wifi_num<2000&&wifi_first==1)//频繁发送心跳指令，认为重启
            {
                wifi_first=0;
            }
            wifi_num=0;
            if(wifi_first==0)//第一次发送心跳数据
            {
                wifi_first=1;
                uint8_t buff_len1 = strlen(Buff1);
                //心跳检测，向涂鸦模块发送
                err = R_SCI_UART_Write(&g_uart0_ctrl, Buff1, buff_len1);
                if(FSP_SUCCESS != err) __BKPT();
                while(uart_wifi_TX_flag == false){}
                uart_wifi_TX_flag = false;

                }
            else
            {
                uint8_t buff_len1 = strlen(Buff2);
                //心跳检测，向涂鸦模块发送
                err = R_SCI_UART_Write(&g_uart0_ctrl, Buff2, buff_len1);
                if(FSP_SUCCESS != err) __BKPT();
                while(uart_wifi_TX_flag == false){}
                uart_wifi_TX_flag = false;

                }
            }



    }

}


/*******************************************************************************************************************//**
 * This function is called at various points during the startup process.  This implementation uses the event that is
 * called right before main() to set up the pins.
 *
 * @param[in]  event    Where at in the start up process the code is currently at
 **********************************************************************************************************************/
void R_BSP_WarmStart(bsp_warm_start_event_t event)
{
    if (BSP_WARM_START_RESET == event)
    {
#if BSP_FEATURE_FLASH_LP_VERSION != 0

        /* Enable reading from data flash. */
        R_FACI_LP->DFLCTL = 1U;

        /* Would normally have to wait tDSTOP(6us) for data flash recovery. Placing the enable here, before clock and
         * C runtime initialization, should negate the need for a delay since the initialization will typically take more than 6us. */
#endif
    }

    if (BSP_WARM_START_POST_C == event)
    {
        /* C runtime environment and system clocks are setup. */

        /* Configure pins. */
        R_IOPORT_Open (&IOPORT_CFG_CTRL, &IOPORT_CFG_NAME);

#if BSP_CFG_SDRAM_ENABLED

        /* Setup SDRAM and initialize it. Must configure pins first. */
        R_BSP_SdramInit(true);
#endif
    }
}

#if BSP_TZ_SECURE_BUILD

FSP_CPP_HEADER
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ();

/* Trustzone Secure Projects require at least one nonsecure callable function in order to build (Remove this if it is not required to build). */
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ()
{

}
FSP_CPP_FOOTER

#endif
